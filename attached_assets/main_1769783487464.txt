import discord
from discord.ext import commands
from discord import app_commands
from discord.ui import View, Select, Modal, TextInput
import datetime
import json
from pathlib import Path
from typing import Optional

intents = discord.Intents.default()
intents.message_content = True
intents.members = True


class GalacticalMC(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix="!", intents=intents)

    async def setup_hook(self):
        synced = await self.tree.sync()
        print(f"Comandi slash sincronizzati: {[c.name for c in synced]}")


bot = [ServerName]()

TICKETS_DATA_FILE = "tickets_data.json"
TRANSCRIPT_DIR = Path("transcripts")
TRANSCRIPT_DIR.mkdir(exist_ok=True)

COLORE_PRINCIPALE = discord.Color.from_rgb(128, 0, 255)
COLORE_SUCCESSO = discord.Color.from_rgb(0, 200, 100)
COLORE_ERRORE = discord.Color.from_rgb(255, 50, 50)

CATEGORIE_TICKETS = {
    "üéÆ Supporto Generale": "supporto-generale",
    "ü§ù Partnership": "partnership",
    "üîê Account / Reset Password": "account-reset",
    "üõí Store / Trasferimento VIP": "store-vip",
    "üêõ Segnala un Bug/Giocatore": "bug-giocatore"
}

DOMANDE_TICKETS = {
    "supporto-generale": [
        {
            "key": "minecraft_name",
            "label": "Nome Minecraft",
            "placeholder": "Inserisci il tuo nickname Minecraft",
            "long": False,
            "required": True
        },
        {
            "key": "what_do_you_need",
            "label": "Di cosa hai bisogno?",
            "placeholder": "Descrivi nel dettaglio di cosa hai bisogno",
            "long": True,
            "required": True
        }
    ],
    "partnership": [
        {
            "key": "discord_server_name",
            "label": "Nome Server Discord",
            "placeholder": "Inserisci il nome del tuo server",
            "long": False,
            "required": True
        },
        {
            "key": "discord_link",
            "label": "Link Discord",
            "placeholder": "https://discord.gg/...",
            "long": False,
            "required": True
        },
        {
            "key": "members",
            "label": "Quanti membri?",
            "placeholder": "Numero approssimativo di membri",
            "long": False,
            "required": True
        },
        {
            "key": "partnership_description",
            "label": "Descrizione Partnership",
            "placeholder": "Spiega perch√© vuoi una partnership con noi",
            "long": True,
            "required": True
        }
    ],
    "account-reset": [
        {
            "key": "minecraft_name",
            "label": "Nome Minecraft",
            "placeholder": "Inserisci il tuo nickname",
            "long": False,
            "required": True
        },
        {
            "key": "is_premium",
            "label": "Sei Premium?",
            "placeholder": "S√¨ / No",
            "long": False,
            "required": True
        },
        {
            "key": "ip",
            "label": "IP di connessione",
            "placeholder": "Inserisci il tuo IP (se lo conosci)",
            "long": False,
            "required": False
        },
        {
            "key": "problem",
            "label": "Descrivi il problema",
            "placeholder": "Spiega cosa non funziona con il tuo account",
            "long": True,
            "required": True
        }
    ],
    "store-vip": [
        {
            "key": "minecraft_name",
            "label": "Nome Minecraft",
            "placeholder": "Inserisci il tuo nickname",
            "long": False,
            "required": True
        },
        {
            "key": "transaction_id",
            "label": "ID Transazione",
            "placeholder": "ID transazione PayPal/Stripe (se disponibile)",
            "long": False,
            "required": False
        },
        {
            "key": "describe_issue",
            "label": "Descrivi il problema",
            "placeholder": "Spiega il problema relativo allo store o trasferimento VIP",
            "long": True,
            "required": True
        }
    ],
    "bug-player": [
        {
            "key": "minecraft_name",
            "label": "Nome Minecraft",
            "placeholder": "Il tuo nickname",
            "long": False,
            "required": True
        },
        {
            "key": "report_type",
            "label": "Tipo di segnalazione",
            "placeholder": "Bug / Giocatore",
            "long": False,
            "required": True
        },
        {
            "key": "player_or_bug_name",
            "label": "Nome giocatore/bug",
            "placeholder": "Nome del giocatore da segnalare o del bug",
            "long": False,
            "required": True
        },
        {
            "key": "description",
            "label": "Descrizione dettagliata",
            "placeholder": "Spiega cosa √® successo in dettaglio",
            "long": True,
            "required": True
        },
        {
            "key": "proof",
            "label": "Prove (link/descrizione)",
            "placeholder": "Link a screenshot, video o altre prove",
            "long": True,
            "required": True
        }
    ]
}


def carica_dati():
    if Path(TICKETS_DATA_FILE).exists():
        with open(TICKETS_DATA_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {"tickets": {}, "closed": {}}


def salva_dati(data):
    with open(TICKETS_DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)


class TicketFormModal(Modal):
    def __init__(self, category: str, staff_role: discord.Role,
                 open_category: discord.CategoryChannel,
                 closed_category: discord.CategoryChannel,
                 logs_channel: discord.TextChannel):
        questions = DOMANDE_TICKETS.get(category, [])
        category_name = next((k.split(" ", 1)[1] for k, v in CATEGORIE_TICKETS.items() if v == category), category)
        super().__init__(title=f"Ticket: {category_name}", timeout=600)

        self.category = category
        self.staff_role = staff_role
        self.open_category = open_category
        self.closed_category = closed_category
        self.logs_channel = logs_channel
        self.inputs = {}

        for question in questions[:5]:
            input_field = TextInput(
                label=question["label"],
                placeholder=question["placeholder"],
                style=discord.TextStyle.paragraph if question["long"] else discord.TextStyle.short,
                required=question["required"],
                max_length=4000 if question["long"] else 100
            )
            self.add_item(input_field)
            self.inputs[question["key"]] = input_field

    async def on_submit(self, interaction: discord.Interaction):
        answers = {k: v.value for k, v in self.inputs.items()}
        await apri_ticket(
            interaction,
            self.category,
            self.staff_role,
            self.open_category,
            self.closed_category,
            self.logs_channel,
            answers
        )


class TicketSelectView(View):
    def __init__(self, staff_role: discord.Role,
                 open_category: discord.CategoryChannel,
                 closed_category: discord.CategoryChannel,
                 logs_channel: discord.TextChannel):
        super().__init__(timeout=None)
        self.staff_role = staff_role
        self.open_category = open_category
        self.closed_category = closed_category
        self.logs_channel = logs_channel

        options = []
        for emoji_label, value in CATEGORIE_TICKETS.items():
            emoji = emoji_label.split(" ")[0]
            label = emoji_label.split(" ", 1)[1]
            options.append(discord.SelectOption(label=label, value=value, emoji=emoji))

        select = Select(
            placeholder="üé´ Seleziona il tipo di ticket...",
            min_values=1,
            max_values=1,
            options=options,
            custom_id="ticket_select"
        )
        select.callback = self.select_callback
        self.add_item(select)

    async def select_callback(self, interaction: discord.Interaction):
        category = interaction.data["values"][0]
        modal = TicketFormModal(
            category,
            self.staff_role,
            self.open_category,
            self.closed_category,
            self.logs_channel
        )
        await interaction.response.send_modal(modal)


class TicketButtonView(View):
    def __init__(self, ticket_owner_id: int, staff_role: discord.Role,
                 closed_category: discord.CategoryChannel,
                 logs_channel: discord.TextChannel,
                 ticket_channel_id: int):
        super().__init__(timeout=None)
        self.ticket_owner_id = ticket_owner_id
        self.staff_role = staff_role
        self.closed_category = closed_category
        self.logs_channel = logs_channel
        self.ticket_channel_id = ticket_channel_id

    @discord.ui.button(label="Claim", style=discord.ButtonStyle.primary, emoji="‚úã", custom_id="claim_ticket")
    async def claim_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await claim_ticket(interaction, self.staff_role, self.logs_channel, self.ticket_channel_id)

    @discord.ui.button(label="Chiudi", style=discord.ButtonStyle.danger, emoji="üîí", custom_id="close_ticket")
    async def close_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await chiudi_ticket(
            interaction,
            self.ticket_owner_id,
            self.staff_role,
            self.closed_category,
            self.logs_channel,
            self.ticket_channel_id
        )


async def apri_ticket(interaction: discord.Interaction, category: str,
                      staff_role: discord.Role,
                      open_category: discord.CategoryChannel,
                      closed_category: discord.CategoryChannel,
                      logs_channel: discord.TextChannel,
                      answers_form: dict):
    await interaction.response.defer(ephemeral=True)

    data = carica_dati()
    user = interaction.user

    for ticket_id, ticket_info in data["tickets"].items():
        if ticket_info["owner_id"] == user.id and not ticket_info["closed"]:
            channel = interaction.guild.get_channel(int(ticket_id))
            if channel:
                await interaction.followup.send(
                    f"‚ùå Hai gi√† un ticket aperto: {channel.mention}",
                    ephemeral=True
                )
                return

    name_ticket = f"ticket-{user.name}".lower().replace(" ", "-")[:50]

    permissions = {
        user: discord.PermissionOverwrite(
            view_channel=True,
            send_messages=True,
            read_message_history=True,
            attach_files=True,
            embed_links=True
        ),
        interaction.guild.default_role: discord.PermissionOverwrite(view_channel=False),
        staff_role: discord.PermissionOverwrite(
            view_channel=True,
            send_messages=True,
            read_message_history=True,
            attach_files=True,
            embed_links=True,
            manage_messages=True
        )
    }

    try:
        ticket_channel = await open_category.create_text_channel(
            name_ticket,
            overwrites=permissions,
            topic=f"Ticket di {user.name} ({user.id}) - Categoria: {category}"
        )
    except Exception as e:
        await interaction.followup.send(
            f"‚ùå Errore nella creazione del ticket: {str(e)}",
            ephemeral=True
        )
        return

    data["tickets"][str(ticket_channel.id)] = {
        "owner_id": user.id,
        "owner_name": user.name,
        "category": category,
        "claimed_by": None,
        "claimed_at": None,
        "created_at": datetime.datetime.now().isoformat(),
        "closed": False,
        "form_answers": answers_form
    }
    salva_dati(data)

    embed_open = discord.Embed(
        title="üé´ Ticket Aperto",
        description=f"Ciao {user.mention}!\\n\\nIl tuo ticket √® stato aperto con successo. Un membro dello staff ti risponder√† il prima possibile.\\n\\n**Categoria**: `{category}`",
        color=COLORE_PRINCIPALE,
        timestamp=datetime.datetime.now()
    )

    if answers_form:
        for key, value in answers_form.items():
            label = key.replace('_', ' ').title()
            embed_open.add_field(
                name=f"üìù {label}",
                value=value[:1024] if value else "N/A",
                inline=False
            )

    embed_open.set_footer(
        text=f"ID Ticket: {ticket_channel.id}",
        icon_url=user.display_avatar.url
    )

    view = TicketButtonView(
        user.id,
        staff_role,
        closed_category,
        logs_channel,
        ticket_channel.id
    )
    await ticket_channel.send(
        content=f"{user.mention} {staff_role.mention}",
        embed=embed_open,
        view=view
    )

    embed_logs = discord.Embed(
        title="üìù Nuovo Ticket Aperto",
        color=COLORE_SUCCESSO,
        timestamp=datetime.datetime.now()
    )
    embed_logs.add_field(name="üë§ Utente", value=f"{user.mention} (`{user.id}`)", inline=True)
    embed_logs.add_field(name="üìÇ Categoria", value=f"`{category}`", inline=True)
    embed_logs.add_field(name="üí¨ Canale", value=ticket_channel.mention, inline=True)
    embed_logs.add_field(name="üÜî ID Ticket", value=f"`{ticket_channel.id}`", inline=False)

    await logs_channel.send(embed=embed_logs)

    await interaction.followup.send(
        f"‚úÖ Ticket creato con successo! Vai su {ticket_channel.mention}",
        ephemeral=True
    )


async def claim_ticket(interaction: discord.Interaction,
                       staff_role: discord.Role,
                       logs_channel: discord.TextChannel,
                       ticket_channel_id: int):
    if staff_role not in interaction.user.roles:
        embed_error = discord.Embed(
            title="‚ùå Errore",
            description="Non hai i permessi per claimare questo ticket.",
            color=COLORE_ERRORE
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    data = carica_dati()
    ticket_key = str(ticket_channel_id)

    if ticket_key not in data["tickets"]:
        await interaction.response.send_message(
            "‚ùå Errore: Ticket non trovato nel database.",
            ephemeral=True
        )
        return

    if data["tickets"][ticket_key]["claimed_by"] is not None:
        claimer_id = data["tickets"][ticket_key]["claimed_by"]
        embed_error = discord.Embed(
            title="‚ùå Ticket gi√† claimato",
            description=f"Questo ticket √® gi√† stato claimato da <@{claimer_id}>.",
            color=COLORE_ERRORE
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    data["tickets"][ticket_key]["claimed_by"] = interaction.user.id
    data["tickets"][ticket_key]["claimed_at"] = datetime.datetime.now().isoformat()
    salva_dati(data)

    embed_claim = discord.Embed(
        title="‚úã Ticket Claimato",
        description=f"**{interaction.user.mention}** ha preso in carico questo ticket.",
        color=COLORE_SUCCESSO,
        timestamp=datetime.datetime.now()
    )
    embed_claim.set_thumbnail(url=interaction.user.display_avatar.url)

    await interaction.response.send_message(embed=embed_claim)

    embed_logs = discord.Embed(
        title="üìù Ticket Claimato",
        color=COLORE_SUCCESSO,
        timestamp=datetime.datetime.now()
    )
    embed_logs.add_field(name="üë§ Staff", value=interaction.user.mention, inline=True)
    embed_logs.add_field(name="üÜî ID Ticket", value=f"`{ticket_channel_id}`", inline=True)

    await logs_channel.send(embed=embed_logs)


async def chiudi_ticket(interaction: discord.Interaction,
                        ticket_owner_id: int,
                        staff_role: discord.Role,
                        closed_category: discord.CategoryChannel,
                        logs_channel: discord.TextChannel,
                        ticket_channel_id: int):
    if staff_role not in interaction.user.roles and interaction.user.id != ticket_owner_id:
        embed_error = discord.Embed(
            title="‚ùå Errore",
            description="Non hai i permessi per chiudere questo ticket.",
            color=COLORE_ERRORE
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    await interaction.response.defer()

    data = carica_dati()
    ticket_key = str(ticket_channel_id)

    if ticket_key not in data["tickets"]:
        await interaction.followup.send("‚ùå Ticket non trovato.", ephemeral=True)
        return

    ticket_data = data["tickets"][ticket_key]
    channel = interaction.channel

    try:
        messages = [msg async for msg in channel.history(limit=500, oldest_first=True)]

        transcript_content = "=" * 70 + "\\n"
        transcript_content += f"TRANSCRIPT TICKET - GalacticalMC\\n"
        transcript_content += "=" * 70 + "\\n\\n"
        transcript_content += f"üìã ID Ticket: {ticket_channel_id}\\n"
        transcript_content += f"üë§ Utente: {ticket_data['owner_name']} (ID: {ticket_data['owner_id']})\\n"
        transcript_content += f"üìÇ Categoria: {ticket_data['category']}\\n"
        transcript_content += f"üìÖ Apertura: {ticket_data['created_at']}\\n"

        if ticket_data["claimed_by"]:
            transcript_content += f"‚úã Claimato da: <@{ticket_data['claimed_by']}> (ID: {ticket_data['claimed_by']})\\n"
            if ticket_data.get("claimed_at"):
                transcript_content += f"üïê Claimato il: {ticket_data['claimed_at']}\\n"

        transcript_content += f"üîí Chiuso da: {interaction.user.name} (ID: {interaction.user.id})\\n"
        transcript_content += f"üïê Chiuso il: {datetime.datetime.now().isoformat()}\\n"

        if ticket_data.get("form_answers"):
            transcript_content += f"\\n{'=' * 70}\\n"
            transcript_content += f"RISPOSTE FORM\\n"
            transcript_content += f"{'=' * 70}\\n\\n"
            for key, value in ticket_data["form_answers"].items():
                transcript_content += f"{key.replace('_', ' ').title()}: {value}\\n"

        transcript_content += f"\\n{'=' * 70}\\n"
        transcript_content += f"MESSAGGI\\n"
        transcript_content += f"{'=' * 70}\\n\\n"

        for msg in messages:
            timestamp = msg.created_at.strftime("%d/%m/%Y %H:%M:%S")
            author = f"{msg.author.name}#{msg.author.discriminator}" if msg.author.discriminator != "0" else msg.author.name
            content = msg.content if msg.content else "[Contenuto multimediale/Embed]"

            transcript_content += f"[{timestamp}] {author}:\\n{content}\\n"

            if msg.attachments:
                transcript_content += f"  üìé Allegati: {', '.join([att.url for att in msg.attachments])}\\n"

            transcript_content += "\\n"

        timestamp_file = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        transcript_path = TRANSCRIPT_DIR / f"ticket_{ticket_channel_id}_{timestamp_file}.txt"

        with open(transcript_path, "w", encoding="utf-8") as f:
            f.write(transcript_content)

    except Exception as e:
        print(f"Errore creazione transcript: {e}")
        transcript_path = None

    if transcript_path and transcript_path.exists():
        try:
            owner = await bot.fetch_user(ticket_owner_id)
            transcript_file = discord.File(transcript_path)

            embed_transcript = discord.Embed(
                title="üìÑ Transcript del tuo Ticket",
                description=f"Il tuo ticket √® stato chiuso. Ecco il transcript completo della conversazione.",
                color=COLORE_PRINCIPALE,
                timestamp=datetime.datetime.now()
            )
            embed_transcript.add_field(name="ID Ticket", value=f"`{ticket_channel_id}`", inline=True)
            embed_transcript.add_field(name="Categoria", value=f"`{ticket_data['category']}`", inline=True)
            embed_transcript.set_footer(text="GalacticalMC Ticket System")

            await owner.send(embed=embed_transcript, file=transcript_file)
        except discord.Forbidden:
            print(f"Impossibile inviare il transcript a {ticket_data['owner_name']} (DM chiusi)")
        except Exception as e:
            print(f"Errore invio transcript: {e}")

    if transcript_path and transcript_path.exists():
        try:
            transcript_file = discord.File(transcript_path)

            embed_logs_close = discord.Embed(
                title="üìù Transcript Salvato",
                color=COLORE_SUCCESSO,
                timestamp=datetime.datetime.now()
            )
            embed_logs_close.add_field(name="üë§ Utente", value=f"<@{ticket_owner_id}>", inline=True)
            embed_logs_close.add_field(name="üîí Chiuso da", value=interaction.user.mention, inline=True)
            embed_logs_close.add_field(name="üÜî ID Ticket", value=f"`{ticket_channel_id}`", inline=False)

            await logs_channel.send(embed=embed_logs_close, file=transcript_file)
        except Exception as e:
            print(f"Errore invio transcript ai logs: {e}")

    category = ticket_data["category"]
    if category not in data["closed"]:
        data["closed"][category] = 0
    data["closed"][category] += 1
    counter = data["closed"][category]

    new_name = f"chiuso-{counter}"

    try:
        await channel.edit(
            name=new_name,
            category=closed_category,
            sync_permissions=True
        )
    except Exception as e:
        print(f"Errore spostamento canale: {e}")

    try:
        await channel.set_permissions(
            interaction.guild.get_member(ticket_owner_id),
            view_channel=False,
            send_messages=False,
            read_message_history=False
        )
    except:
        pass

    embed_closure = discord.Embed(
        title="üîí Ticket Chiuso",
        description=f"Questo ticket √® stato chiuso da **{interaction.user.mention}**.\\n\\nIl transcript √® stato salvato e inviato all'utente.",
        color=COLORE_ERRORE,
        timestamp=datetime.datetime.now()
    )
    embed_closure.add_field(name="Chiuso da", value=interaction.user.mention, inline=True)
    embed_closure.add_field(name="Nuovo nome", value=f"`{new_name}`", inline=True)

    await channel.send(embed=embed_closure)

    data["tickets"][ticket_key]["closed"] = True
    data["tickets"][ticket_key]["closed_by"] = interaction.user.id
    data["tickets"][ticket_key]["closed_at"] = datetime.datetime.now().isoformat()
    salva_dati(data)

    embed_logs_final = discord.Embed(
        title="üìù Ticket Chiuso",
        color=COLORE_ERRORE,
        timestamp=datetime.datetime.now()
    )
    embed_logs_final.add_field(name="üë§ Utente", value=f"<@{ticket_owner_id}>", inline=True)
    embed_logs_final.add_field(
        name="‚úã Claimato da",
        value=f"<@{ticket_data['claimed_by']}>" if ticket_data.get("claimed_by") else "Non claimato",
        inline=True
    )
    embed_logs_final.add_field(name="üîí Chiuso da", value=interaction.user.mention, inline=True)
    embed_logs_final.add_field(name="üìù Nuovo nome", value=f"`{new_name}`", inline=True)
    embed_logs_final.add_field(name="üÜî ID", value=f"`{ticket_channel_id}`", inline=True)

    await logs_channel.send(embed=embed_logs_final)


@bot.tree.command(name="support", description="Crea il pannello dei ticket")
@app_commands.default_permissions(manage_guild=True)
@app_commands.describe(
    channel="Canale dove inviare il pannello",
    open_category="Categoria per i ticket aperti",
    closed_category="Categoria per i ticket chiusi",
    logs_channel="Canale per i log",
    staff_role="Ruolo staff che gestisce i ticket",
    image_url="URL immagine per l'embed (opzionale)"
)
async def support(
    interaction: discord.Interaction,
    channel: discord.TextChannel,
    open_category: discord.CategoryChannel,
    closed_category: discord.CategoryChannel,
    logs_channel: discord.TextChannel,
    staff_role: discord.Role,
    image_url: Optional[str] = None
):
    embed_support = discord.Embed(
        title="üé´ [ServerName] - Sistema Ticket",
        description=(
            "**Benvenuto nel sistema di supporto di [ServerName]!**\\n\\n"
            "Se hai bisogno di assistenza, vuoi segnalare un problema o richiedere informazioni, "
            "apri un ticket selezionando la categoria appropriata dal menu qui sotto.\\n\\n"
            "üìã **Istruzioni:**\\n"
            "‚Ä¢ Seleziona la categoria che meglio descrive la tua richiesta\\n"
            "‚Ä¢ Compila il form con tutte le informazioni richieste\\n"
            "‚Ä¢ Attendi che un membro dello staff prenda in carico il ticket\\n\\n"
            "‚ö†Ô∏è **Attenzione:** Non aprire ticket troll o spam, verrai sanzionato!\\n"
            "Fornisci sempre dettagli chiari e, se necessario, allega prove (screenshot/video)."
        ),
        color=COLORE_PRINCIPALE,
        timestamp=datetime.datetime.now()
    )

    if image_url:
        embed_support.set_thumbnail(url=image_url)

    embed_support.set_footer(
        text="Seleziona una categoria dal menu per aprire un ticket",
        icon_url=interaction.guild.icon.url if interaction.guild.icon else None
    )

    view = TicketSelectView(
        staff_role,
        open_category,
        closed_category,
        logs_channel
    )

    await channel.send(embed=embed_support, view=view)

    await interaction.response.send_message(
        f"‚úÖ Pannello ticket creato con successo in {channel.mention}!",
        ephemeral=True
    )


@bot.tree.command(name="claim", description="Prendi in carico il ticket corrente")
async def claim_command(interaction: discord.Interaction):
    data = carica_dati()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        embed_error = discord.Embed(
            title="‚ùå Errore",
            description="Questo comando pu√≤ essere usato solo in un canale ticket.",
            color=COLORE_ERRORE
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    if not staff_role:
        await interaction.response.send_message(
            "‚ùå Ruolo 'Staff' non trovato.",
            ephemeral=True
        )
        return

    logs_channel = discord.utils.get(interaction.guild.text_channels, name="ticket-logs")
    if not logs_channel:
        logs_channel = interaction.channel

    await claim_ticket(interaction, staff_role, logs_channel, interaction.channel.id)


@bot.tree.command(name="unclaim", description="Rilascia il ticket corrente")
async def unclaim_command(interaction: discord.Interaction):
    data = carica_dati()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        embed_error = discord.Embed(
            title="‚ùå Errore",
            description="Questo comando pu√≤ essere usato solo in un canale ticket.",
            color=COLORE_ERRORE
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    ticket_data = data["tickets"][ticket_key]

    if data["tickets"][ticket_key]["claimed_by"] != interaction.user.id:
        if not staff_role or staff_role not in interaction.user.roles:
            embed_error = discord.Embed(
                title="‚ùå Errore",
                description="Solo chi ha claimato il ticket pu√≤ rilasciarlo.",
                color=COLORE_ERRORE
            )
            await interaction.response.send_message(embed=embed_error, ephemeral=True)
            return

    data["tickets"][ticket_key]["claimed_by"] = None
    data["tickets"][ticket_key]["claimed_at"] = None
    salva_dati(data)

    embed_unclaim = discord.Embed(
        title="üîì Ticket Rilasciato",
        description=f"{interaction.user.mention} ha rilasciato questo ticket.\\n\\nOra pu√≤ essere claimato da un altro membro dello staff.",
        color=COLORE_PRINCIPALE,
        timestamp=datetime.datetime.now()
    )

    await interaction.response.send_message(embed=embed_unclaim)


@bot.tree.command(name="close", description="Chiudi il ticket corrente")
async def close_command(interaction: discord.Interaction):
    data = carica_dati()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        embed_error = discord.Embed(
            title="‚ùå Errore",
            description="Questo comando pu√≤ essere usato solo in un canale ticket.",
            color=COLORE_ERRORE
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    ticket_data = data["tickets"][ticket_key]

    if ticket_data["closed"]:
        await interaction.response.send_message(
            "‚ùå Questo ticket √® gi√† stato chiuso.",
            ephemeral=True
        )
        return

    owner_id = ticket_data["owner_id"]

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    closed_category = discord.utils.get(interaction.guild.categories, name="Ticket Chiusi")
    logs_channel = discord.utils.get(interaction.guild.text_channels, name="ticket-logs")

    if not closed_category:
        closed_category = interaction.channel.category

    if not logs_channel:
        logs_channel = interaction.channel

    await chiudi_ticket(
        interaction,
        owner_id,
        staff_role,
        closed_category,
        logs_channel,
        interaction.channel.id
    )


@bot.tree.command(name="add", description="Aggiungi un utente al ticket")
@app_commands.describe(user="L'utente da aggiungere al ticket")
async def add_user(interaction: discord.Interaction, user: discord.Member):
    data = carica_dati()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        await interaction.response.send_message(
            "‚ùå Questo non √® un canale ticket.",
            ephemeral=True
        )
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    ticket_data = data["tickets"][ticket_key]

    if staff_role not in interaction.user.roles and interaction.user.id != ticket_data["owner_id"]:
        await interaction.response.send_message(
            "‚ùå Non hai i permessi per aggiungere utenti.",
            ephemeral=True
        )
        return

    await interaction.channel.set_permissions(
        user,
        view_channel=True,
        send_messages=True,
        read_message_history=True
    )

    embed = discord.Embed(
        title="‚úÖ Utente Aggiunto",
        description=f"{user.mention} √® stato aggiunto al ticket.",
        color=COLORE_SUCCESSO
    )

    await interaction.response.send_message(embed=embed)


@bot.tree.command(name="remove", description="Rimuovi un utente dal ticket")
@app_commands.describe(user="L'utente da rimuovere dal ticket")
async def remove_user(interaction: discord.Interaction, user: discord.Member):
    data = carica_dati()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        await interaction.response.send_message(
            "‚ùå Questo non √® un canale ticket.",
            ephemeral=True
        )
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    ticket_data = data["tickets"][ticket_key]

    if staff_role not in interaction.user.roles:
        await interaction.response.send_message(
            "‚ùå Solo lo staff pu√≤ rimuovere utenti.",
            ephemeral=True
        )
        return

    if user.id == ticket_data["owner_id"]:
        await interaction.response.send_message(
            "‚ùå Non puoi rimuovere il proprietario del ticket.",
            ephemeral=True
        )
        return

    await interaction.channel.set_permissions(user, overwrite=None)

    embed = discord.Embed(
        title="‚úÖ Utente Rimosso",
        description=f"{user.mention} √® stato rimosso dal ticket.",
        color=COLORE_SUCCESSO
    )

    await interaction.response.send_message(embed=embed)


@bot.command()
@commands.is_owner()
async def sync(ctx):
    synced = await bot.tree.sync()
    await ctx.send(f"‚úÖ Sincronizzati {len(synced)} comandi: {[c.name for c in synced]}")


@bot.event
async def on_ready():
    print(f"‚úÖ Bot connesso come {bot.user}")
    print(f"üìä Guild: {len(bot.guilds)}")
    print(f"üë• Utenti: {len(bot.users)}")

    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="[ServerName]"
        ),
        status=discord.Status.online
    )


bot.run("[TOKEN]")
