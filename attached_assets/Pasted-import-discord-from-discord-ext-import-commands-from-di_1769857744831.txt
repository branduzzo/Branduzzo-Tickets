import discord
from discord.ext import commands
from discord import app_commands
from discord.ui import View, Select, Modal, TextInput
import datetime
import json
from pathlib import Path
from typing import Optional

intents = discord.Intents.default()
intents.message_content = True
intents.members = True


class [ServerName](commands.Bot):
    def __init__(self):
        super().__init__(command_prefix="!", intents=intents)

    async def setup_hook(self):
        synced = await self.tree.sync()
        print(f"Comandos slash sincronizados: {[c.name for c in synced]}")


bot = [ServerName]()

TICKETS_DATA_FILE = "tickets_data.json"
TRANSCRIPT_DIR = Path("transcripts")
TRANSCRIPT_DIR.mkdir(exist_ok=True)

COULEUR_PRINCIPALE = discord.Color.from_rgb(128, 0, 255)
COULEUR_SUCCES = discord.Color.from_rgb(0, 200, 100)
COULEUR_ERREUR = discord.Color.from_rgb(255, 50, 50)

CATEGORIES_TICKETS = {
    "üéÆ Soporte General": "support-general",
    "ü§ù Partnership": "partnership",
    "üîê Cuenta / Restablecer Contrase√±a": "account-reset",
    "üõí Tienda / Transferencia VIP": "store-vip",
    "üêõ Reportar Bug/Jugador": "bug-player"
}

QUESTIONS_TICKETS = {
    "support-general": [
        {
            "key": "minecraft_name",
            "label": "Nombre de Minecraft",
            "placeholder": "Introduce tu nick de Minecraft",
            "long": False,
            "required": True
        },
        {
            "key": "what_do_you_need",
            "label": "¬øEn qu√© necesitas ayuda?",
            "placeholder": "Describe en detalle en qu√© necesitas ayuda",
            "long": True,
            "required": True
        }
    ],
    "partnership": [
        {
            "key": "discord_server_name",
            "label": "Nombre del servidor de Discord",
            "placeholder": "Introduce el nombre de tu servidor",
            "long": False,
            "required": True
        },
        {
            "key": "discord_link",
            "label": "Enlace de Discord",
            "placeholder": "https://discord.gg/...",
            "long": False,
            "required": True
        },
        {
            "key": "members",
            "label": "N√∫mero de miembros",
            "placeholder": "N√∫mero aproximado de miembros",
            "long": False,
            "required": True
        },
        {
            "key": "partnership_description",
            "label": "Descripci√≥n de la partnership",
            "placeholder": "Explica por qu√© quieres una partnership con nosotros",
            "long": True,
            "required": True
        }
    ],
    "account-reset": [
        {
            "key": "minecraft_name",
            "label": "Nombre de Minecraft",
            "placeholder": "Introduce tu nick",
            "long": False,
            "required": True
        },
        {
            "key": "is_premium",
            "label": "¬øEres premium?",
            "placeholder": "S√≠ / No",
            "long": False,
            "required": True
        },
        {
            "key": "ip",
            "label": "Direcci√≥n IP de conexi√≥n",
            "placeholder": "Introduce tu IP (si la conoces)",
            "long": False,
            "required": False
        },
        {
            "key": "problem",
            "label": "Describe el problema",
            "placeholder": "Explica qu√© es lo que no funciona con tu cuenta",
            "long": True,
            "required": True
        }
    ],
    "store-vip": [
        {
            "key": "minecraft_name",
            "label": "Nombre de Minecraft",
            "placeholder": "Introduce tu nick",
            "long": False,
            "required": True
        },
        {
            "key": "transaction_id",
            "label": "ID de transacci√≥n",
            "placeholder": "ID de transacci√≥n PayPal/Stripe (si est√° disponible)",
            "long": False,
            "required": False
        },
        {
            "key": "describe_issue",
            "label": "Describe el problema",
            "placeholder": "Explica el problema relacionado con la tienda o la transferencia VIP",
            "long": True,
            "required": True
        }
    ],
    "bug-player": [
        {
            "key": "minecraft_name",
            "label": "Nombre de Minecraft",
            "placeholder": "Tu nick",
            "long": False,
            "required": True
        },
        {
            "key": "report_type",
            "label": "Tipo de reporte",
            "placeholder": "Bug / Jugador",
            "long": False,
            "required": True
        },
        {
            "key": "player_or_bug_name",
            "label": "Nombre del jugador/bug",
            "placeholder": "Nombre del jugador a reportar o del bug",
            "long": False,
            "required": True
        },
        {
            "key": "description",
            "label": "Descripci√≥n detallada",
            "placeholder": "Explica en detalle lo que ha ocurrido",
            "long": True,
            "required": True
        },
        {
            "key": "proof",
            "label": "Pruebas (enlace/descripci√≥n)",
            "placeholder": "Enlace a captura, v√≠deo u otras pruebas",
            "long": True,
            "required": True
        }
    ]
}


def cargar_datos():
    if Path(TICKETS_DATA_FILE).exists():
        with open(TICKETS_DATA_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {"tickets": {}, "closed": {}}


def guardar_datos(data):
    with open(TICKETS_DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)


class TicketFormModal(Modal):
    def __init__(self, category: str, staff_role: discord.Role,
                 open_category: discord.CategoryChannel,
                 closed_category: discord.CategoryChannel,
                 logs_channel: discord.TextChannel):
        questions = QUESTIONS_TICKETS.get(category, [])
        category_name = next((k.split(" ", 1)[1] for k, v in CATEGORIES_TICKETS.items() if v == category), category)
        super().__init__(title=f"Ticket: {category_name}", timeout=600)

        self.category = category
        self.staff_role = staff_role
        self.open_category = open_category
        self.closed_category = closed_category
        self.logs_channel = logs_channel
        self.inputs = {}

        for question in questions[:5]:
            input_field = TextInput(
                label=question["label"],
                placeholder=question["placeholder"],
                style=discord.TextStyle.paragraph if question["long"] else discord.TextStyle.short,
                required=question["required"],
                max_length=4000 if question["long"] else 100
            )
            self.add_item(input_field)
            self.inputs[question["key"]] = input_field

    async def on_submit(self, interaction: discord.Interaction):
        answers = {k: v.value for k, v in self.inputs.items()}
        await abrir_ticket(
            interaction,
            self.category,
            self.staff_role,
            self.open_category,
            self.closed_category,
            self.logs_channel,
            answers
        )


class TicketSelectView(View):
    def __init__(self, staff_role: discord.Role,
                 open_category: discord.CategoryChannel,
                 closed_category: discord.CategoryChannel,
                 logs_channel: discord.TextChannel):
        super().__init__(timeout=None)
        self.staff_role = staff_role
        self.open_category = open_category
        self.closed_category = closed_category
        self.logs_channel = logs_channel

        options = []
        for emoji_label, value in CATEGORIES_TICKETS.items():
            emoji = emoji_label.split(" ")[0]
            label = emoji_label.split(" ", 1)[1]
            options.append(discord.SelectOption(label=label, value=value, emoji=emoji))

        select = Select(
            placeholder="üé´ Selecciona el tipo de ticket...",
            min_values=1,
            max_values=1,
            options=options,
            custom_id="ticket_select"
        )
        select.callback = self.select_callback
        self.add_item(select)

    async def select_callback(self, interaction: discord.Interaction):
        category = interaction.data["values"][0]
        modal = TicketFormModal(
            category,
            self.staff_role,
            self.open_category,
            self.closed_category,
            self.logs_channel
        )
        await interaction.response.send_modal(modal)


class TicketButtonView(View):
    def __init__(self, ticket_owner_id: int, staff_role: discord.Role,
                 closed_category: discord.CategoryChannel,
                 logs_channel: discord.TextChannel,
                 ticket_channel_id: int):
        super().__init__(timeout=None)
        self.ticket_owner_id = ticket_owner_id
        self.staff_role = staff_role
        self.closed_category = closed_category
        self.logs_channel = logs_channel
        self.ticket_channel_id = ticket_channel_id

    @discord.ui.button(label="Claim", style=discord.ButtonStyle.primary, emoji="‚úã", custom_id="claim_ticket")
    async def claim_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await claim_ticket(interaction, self.staff_role, self.logs_channel, self.ticket_channel_id)

    @discord.ui.button(label="Cerrar", style=discord.ButtonStyle.danger, emoji="üîí", custom_id="close_ticket")
    async def close_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await cerrar_ticket(
            interaction,
            self.ticket_owner_id,
            self.staff_role,
            self.closed_category,
            self.logs_channel,
            self.ticket_channel_id
        )


async def abrir_ticket(interaction: discord.Interaction, category: str,
                       staff_role: discord.Role,
                       open_category: discord.CategoryChannel,
                       closed_category: discord.CategoryChannel,
                       logs_channel: discord.TextChannel,
                       answers_form: dict):
    await interaction.response.defer(ephemeral=True)

    data = cargar_datos()
    user = interaction.user

    for ticket_id, ticket_info in data["tickets"].items():
        if ticket_info["owner_id"] == user.id and not ticket_info["closed"]:
            channel = interaction.guild.get_channel(int(ticket_id))
            if channel:
                await interaction.followup.send(
                    f"‚ùå Ya tienes un ticket abierto: {channel.mention}",
                    ephemeral=True
                )
                return

    name_ticket = f"ticket-{user.name}".lower().replace(" ", "-")[:50]

    permissions = {
        user: discord.PermissionOverwrite(
            view_channel=True,
            send_messages=True,
            read_message_history=True,
            attach_files=True,
            embed_links=True
        ),
        interaction.guild.default_role: discord.PermissionOverwrite(view_channel=False),
        staff_role: discord.PermissionOverwrite(
            view_channel=True,
            send_messages=True,
            read_message_history=True,
            attach_files=True,
            embed_links=True,
            manage_messages=True
        )
    }

    try:
        ticket_channel = await open_category.create_text_channel(
            name_ticket,
            overwrites=permissions,
            topic=f"Ticket de {user.name} ({user.id}) - Categor√≠a: {category}"
        )
    except Exception as e:
        await interaction.followup.send(
            f"‚ùå Error al crear el ticket: {str(e)}",
            ephemeral=True
        )
        return

    data["tickets"][str(ticket_channel.id)] = {
        "owner_id": user.id,
        "owner_name": user.name,
        "category": category,
        "claimed_by": None,
        "claimed_at": None,
        "created_at": datetime.datetime.now().isoformat(),
        "closed": False,
        "form_answers": answers_form
    }
    guardar_datos(data)

    embed_open = discord.Embed(
        title="üé´ Ticket Abierto",
        description=f"Hola {user.mention}.\n\nTu ticket se ha abierto correctamente. Un miembro del staff te responder√° lo antes posible.\n\nCategor√≠a: `{category}`",
        color=COULEUR_PRINCIPALE,
        timestamp=datetime.datetime.now()
    )

    if answers_form:
        for key, value in answers_form.items():
            label = key.replace('_', ' ').title()
            embed_open.add_field(
                name=f"üìù {label}",
                value=value[:1024] if value else "N/D",
                inline=False
            )

    embed_open.set_footer(
        text=f"ID Ticket: {ticket_channel.id}",
        icon_url=user.display_avatar.url
    )

    view = TicketButtonView(
        user.id,
        staff_role,
        closed_category,
        logs_channel,
        ticket_channel.id
    )
    await ticket_channel.send(
        content=f"{user.mention} {staff_role.mention}",
        embed=embed_open,
        view=view
    )

    embed_logs = discord.Embed(
        title="üìù Nuevo Ticket Abierto",
        color=COULEUR_SUCCES,
        timestamp=datetime.datetime.now()
    )
    embed_logs.add_field(name="üë§ Usuario", value=f"{user.mention} (`{user.id}`)", inline=True)
    embed_logs.add_field(name="üìÇ Categor√≠a", value=f"`{category}`", inline=True)
    embed_logs.add_field(name="üí¨ Canal", value=ticket_channel.mention, inline=True)
    embed_logs.add_field(name="üÜî ID Ticket", value=f"`{ticket_channel.id}`", inline=False)

    await logs_channel.send(embed=embed_logs)

    await interaction.followup.send(
        f"‚úÖ Ticket creado correctamente. Ve a {ticket_channel.mention}",
        ephemeral=True
    )


async def claim_ticket(interaction: discord.Interaction,
                       staff_role: discord.Role,
                       logs_channel: discord.TextChannel,
                       ticket_channel_id: int):
    if staff_role not in interaction.user.roles:
        embed_error = discord.Embed(
            title="‚ùå Error",
            description="No tienes permiso para claimar este ticket.",
            color=COULEUR_ERREUR
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    data = cargar_datos()
    ticket_key = str(ticket_channel_id)

    if ticket_key not in data["tickets"]:
        await interaction.response.send_message(
            "‚ùå Error: ticket no encontrado en la base de datos.",
            ephemeral=True
        )
        return

    if data["tickets"][ticket_key]["claimed_by"] is not None:
        claimer_id = data["tickets"][ticket_key]["claimed_by"]
        embed_error = discord.Embed(
            title="‚ùå Ticket ya claimado",
            description=f"Este ticket ya ha sido claimado por <@{claimer_id}>.",
            color=COULEUR_ERREUR
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    data["tickets"][ticket_key]["claimed_by"] = interaction.user.id
    data["tickets"][ticket_key]["claimed_at"] = datetime.datetime.now().isoformat()
    guardar_datos(data)

    embed_claim = discord.Embed(
        title="‚úã Ticket Claimado",
        description=f"{interaction.user.mention} ha tomado este ticket.",
        color=COULEUR_SUCCES,
        timestamp=datetime.datetime.now()
    )
    embed_claim.set_thumbnail(url=interaction.user.display_avatar.url)

    await interaction.response.send_message(embed=embed_claim)

    embed_logs = discord.Embed(
        title="üìù Ticket Claimado",
        color=COULEUR_SUCCES,
        timestamp=datetime.datetime.now()
    )
    embed_logs.add_field(name="üë§ Staff", value=interaction.user.mention, inline=True)
    embed_logs.add_field(name="üÜî ID Ticket", value=f"`{ticket_channel_id}`", inline=True)

    await logs_channel.send(embed=embed_logs)


async def cerrar_ticket(interaction: discord.Interaction,
                        ticket_owner_id: int,
                        staff_role: discord.Role,
                        closed_category: discord.CategoryChannel,
                        logs_channel: discord.TextChannel,
                        ticket_channel_id: int):
    if staff_role not in interaction.user.roles and interaction.user.id != ticket_owner_id:
        embed_error = discord.Embed(
            title="‚ùå Error",
            description="No tienes permiso para cerrar este ticket.",
            color=COULEUR_ERREUR
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    await interaction.response.defer()

    data = cargar_datos()
    ticket_key = str(ticket_channel_id)

    if ticket_key not in data["tickets"]:
        await interaction.followup.send("‚ùå Ticket no encontrado.", ephemeral=True)
        return

    ticket_data = data["tickets"][ticket_key]
    channel = interaction.channel

    try:
        messages = [msg async for msg in channel.history(limit=500, oldest_first=True)]

        transcript_content = "=" * 70 + "\n"
        transcript_content += "TRANSCRIPT TICKET - [ServerName]\n"
        transcript_content += "=" * 70 + "\n\n"
        transcript_content += f"üìã ID Ticket: {ticket_channel_id}\n"
        transcript_content += f"üë§ Usuario: {ticket_data['owner_name']} (ID: {ticket_data['owner_id']})\n"
        transcript_content += f"üìÇ Categor√≠a: {ticket_data['category']}\n"
        transcript_content += f"üìÖ Apertura: {ticket_data['created_at']}\n"

        if ticket_data["claimed_by"]:
            transcript_content += f"‚úã Claimeado por: <@{ticket_data['claimed_by']}> (ID: {ticket_data['claimed_by']})\n"
            if ticket_data.get("claimed_at"):
                transcript_content += f"üïê Claimeado el: {ticket_data['claimed_at']}\n"

        transcript_content += f"üîí Cerrado por: {interaction.user.name} (ID: {interaction.user.id})\n"
        transcript_content += f"üïê Cerrado el: {datetime.datetime.now().isoformat()}\n"

        if ticket_data.get("form_answers"):
            transcript_content += "\n" + "=" * 70 + "\n"
            transcript_content += "RESPUESTAS DEL FORMULARIO\n"
            transcript_content += "=" * 70 + "\n\n"
            for key, value in ticket_data["form_answers"].items():
                transcript_content += f"{key.replace('_', ' ').title()}: {value}\n"

        transcript_content += "\n" + "=" * 70 + "\n"
        transcript_content += "MENSAJES\n"
        transcript_content += "=" * 70 + "\n\n"

        for msg in messages:
            timestamp = msg.created_at.strftime("%d/%m/%Y %H:%M:%S")
            author = f"{msg.author.name}#{msg.author.discriminator}" if msg.author.discriminator != "0" else msg.author.name
            content = msg.content if msg.content else "[Contenido multimedia/Embed]"

            transcript_content += f"[{timestamp}] {author}:\n{content}\n"

            if msg.attachments:
                transcript_content += "  üìé Archivos adjuntos: " + ", ".join([att.url for att in msg.attachments]) + "\n"

            transcript_content += "\n"

        timestamp_file = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        transcript_path = TRANSCRIPT_DIR / f"ticket_{ticket_channel_id}_{timestamp_file}.txt"

        with open(transcript_path, "w", encoding="utf-8") as f:
            f.write(transcript_content)

    except Exception as e:
        print(f"Error al crear el transcript: {e}")
        transcript_path = None

    if transcript_path and transcript_path.exists():
        try:
            owner = await bot.fetch_user(ticket_owner_id)
            transcript_file = discord.File(transcript_path)

            embed_transcript = discord.Embed(
                title="üìÑ Transcript del Ticket",
                description="Tu ticket ha sido cerrado. Aqu√≠ tienes el transcript completo de la conversaci√≥n.",
                color=COULEUR_PRINCIPALE,
                timestamp=datetime.datetime.now()
            )
            embed_transcript.add_field(name="ID Ticket", value=f"`{ticket_channel_id}`", inline=True)
            embed_transcript.add_field(name="Categor√≠a", value=f"`{ticket_data['category']}`", inline=True)
            embed_transcript.set_footer(text="[ServerName] - Sistema de Tickets")

            await owner.send(embed=embed_transcript, file=transcript_file)
        except discord.Forbidden:
            print(f"No se pudo enviar el transcript a {ticket_data['owner_name']} (DM cerrados)")
        except Exception as e:
            print(f"Error al enviar el transcript: {e}")

    if transcript_path and transcript_path.exists():
        try:
            transcript_file = discord.File(transcript_path)

            embed_logs_close = discord.Embed(
                title="üìù Transcript Guardado",
                color=COULEUR_SUCCES,
                timestamp=datetime.datetime.now()
            )
            embed_logs_close.add_field(name="üë§ Usuario", value=f"<@{ticket_owner_id}>", inline=True)
            embed_logs_close.add_field(name="üîí Cerrado por", value=interaction.user.mention, inline=True)
            embed_logs_close.add_field(name="üÜî ID Ticket", value=f"`{ticket_channel_id}`", inline=False)

            await logs_channel.send(embed=embed_logs_close, file=transcript_file)
        except Exception as e:
            print(f"Error al enviar el transcript a los logs: {e}")

    category = ticket_data["category"]
    if category not in data["closed"]:
        data["closed"][category] = 0
    data["closed"][category] += 1
    counter = data["closed"][category]

    new_name = f"cerrado-{counter}"

    try:
        await channel.edit(
            name=new_name,
            category=closed_category,
            sync_permissions=True
        )
    except Exception as e:
        print(f"Error al mover el canal: {e}")

    try:
        await channel.set_permissions(
            interaction.guild.get_member(ticket_owner_id),
            view_channel=False,
            send_messages=False,
            read_message_history=False
        )
    except:
        pass

    embed_closure = discord.Embed(
        title="üîí Ticket Cerrado",
        description=f"Este ticket ha sido cerrado por {interaction.user.mention}.\n\nEl transcript ha sido guardado y enviado al usuario.",
        color=COULEUR_ERREUR,
        timestamp=datetime.datetime.now()
    )
    embed_closure.add_field(name="Cerrado por", value=interaction.user.mention, inline=True)
    embed_closure.add_field(name="Nuevo nombre", value=f"`{new_name}`", inline=True)

    await channel.send(embed=embed_closure)

    data["tickets"][ticket_key]["closed"] = True
    data["tickets"][ticket_key]["closed_by"] = interaction.user.id
    data["tickets"][ticket_key]["closed_at"] = datetime.datetime.now().isoformat()
    guardar_datos(data)

    embed_logs_final = discord.Embed(
        title="üìù Ticket Cerrado",
        color=COULEUR_ERREUR,
        timestamp=datetime.datetime.now()
    )
    embed_logs_final.add_field(name="üë§ Usuario", value=f"<@{ticket_owner_id}>", inline=True)
    embed_logs_final.add_field(
        name="‚úã Claimeado por",
        value=f"<@{ticket_data['claimed_by']}>" if ticket_data.get("claimed_by") else "No claimeado",
        inline=True
    )
    embed_logs_final.add_field(name="üîí Cerrado por", value=interaction.user.mention, inline=True)
    embed_logs_final.add_field(name="Nuevo nombre", value=f"`{new_name}`", inline=True)
    embed_logs_final.add_field(name="üÜî ID", value=f"`{ticket_channel_id}`", inline=True)

    await logs_channel.send(embed=embed_logs_final)


@bot.tree.command(name="support", description="Crear el panel de tickets")
@app_commands.default_permissions(manage_guild=True)
@app_commands.describe(
    channel="Canal donde enviar el panel",
    open_category="Categor√≠a para los tickets abiertos",
    closed_category="Categor√≠a para los tickets cerrados",
    logs_channel="Canal para los logs",
    staff_role="Rol staff que gestiona los tickets",
    image_url="URL de la imagen para el embed (opcional)"
)
async def support(
    interaction: discord.Interaction,
    channel: discord.TextChannel,
    open_category: discord.CategoryChannel,
    closed_category: discord.CategoryChannel,
    logs_channel: discord.TextChannel,
    staff_role: discord.Role,
    image_url: Optional[str] = None
):
    embed_support = discord.Embed(
        title="üé´ [ServerName] - Sistema de Tickets",
        description=(
            "**Bienvenido al sistema de soporte de [ServerName].**\n\n"
            "Si necesitas ayuda, quieres reportar un problema o hacer preguntas, "
            "abre un ticket seleccionando la categor√≠a adecuada en el men√∫ de abajo.\n\n"
            "üìã Instrucciones:\n"
            "‚Ä¢ Selecciona la categor√≠a que mejor describa tu solicitud\n"
            "‚Ä¢ Rellena el formulario con toda la informaci√≥n requerida\n"
            "‚Ä¢ Espera a que un miembro del staff tome el ticket\n\n"
            "‚ö†Ô∏è Atenci√≥n: no crees tickets de troll o spam, ser√°s sancionado.\n"
            "Proporciona siempre detalles claros y, si es necesario, adjunta pruebas (capturas/v√≠deos)."
        ),
        color=COULEUR_PRINCIPALE,
        timestamp=datetime.datetime.now()
    )

    if image_url:
        embed_support.set_thumbnail(url=image_url)

    embed_support.set_footer(
        text="Selecciona una categor√≠a en el men√∫ para abrir un ticket",
        icon_url=interaction.guild.icon.url if interaction.guild.icon else None
    )

    view = TicketSelectView(
        staff_role,
        open_category,
        closed_category,
        logs_channel
    )

    await channel.send(embed=embed_support, view=view)

    await interaction.response.send_message(
        f"‚úÖ Panel de tickets creado correctamente en {channel.mention}.",
        ephemeral=True
    )


@bot.tree.command(name="claim", description="Tomar el ticket actual")
async def claim_command(interaction: discord.Interaction):
    data = cargar_datos()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        embed_error = discord.Embed(
            title="‚ùå Error",
            description="Este comando solo puede usarse en un canal de ticket.",
            color=COULEUR_ERREUR
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    if not staff_role:
        await interaction.response.send_message(
            "‚ùå Rol 'Staff' no encontrado.",
            ephemeral=True
        )
        return

    logs_channel = discord.utils.get(interaction.guild.text_channels, name="ticket-logs")
    if not logs_channel:
        logs_channel = interaction.channel

    await claim_ticket(interaction, staff_role, logs_channel, interaction.channel.id)


@bot.tree.command(name="unclaim", description="Liberar el ticket actual")
async def unclaim_command(interaction: discord.Interaction):
    data = cargar_datos()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        embed_error = discord.Embed(
            title="‚ùå Error",
            description="Este comando solo puede usarse en un canal de ticket.",
            color=COULEUR_ERREUR
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    ticket_data = data["tickets"][ticket_key]

    if data["tickets"][ticket_key]["claimed_by"] != interaction.user.id:
        if not staff_role or staff_role not in interaction.user.roles:
            embed_error = discord.Embed(
                title="‚ùå Error",
                description="Solo la persona que ha claimado el ticket puede liberarlo.",
                color=COULEUR_ERREUR
            )
            await interaction.response.send_message(embed=embed_error, ephemeral=True)
            return

    data["tickets"][ticket_key]["claimed_by"] = None
    data["tickets"][ticket_key]["claimed_at"] = None
    guardar_datos(data)

    embed_unclaim = discord.Embed(
        title="üîì Ticket Liberado",
        description=f"{interaction.user.mention} ha liberado este ticket.\n\nAhora puede ser claimado por otro miembro del staff.",
        color=COULEUR_PRINCIPALE,
        timestamp=datetime.datetime.now()
    )

    await interaction.response.send_message(embed=embed_unclaim)


@bot.tree.command(name="close", description="Cerrar el ticket actual")
async def close_command(interaction: discord.Interaction):
    data = cargar_datos()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        embed_error = discord.Embed(
            title="‚ùå Error",
            description="Este comando solo puede usarse en un canal de ticket.",
            color=COULEUR_ERREUR
        )
        await interaction.response.send_message(embed=embed_error, ephemeral=True)
        return

    ticket_data = data["tickets"][ticket_key]

    if ticket_data["closed"]:
        await interaction.response.send_message(
            "‚ùå Este ticket ya est√° cerrado.",
            ephemeral=True
        )
        return

    owner_id = ticket_data["owner_id"]

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    closed_category = discord.utils.get(interaction.guild.categories, name="Tickets Cerrados")
    logs_channel = discord.utils.get(interaction.guild.text_channels, name="ticket-logs")

    if not closed_category:
        closed_category = interaction.channel.category

    if not logs_channel:
        logs_channel = interaction.channel

    await cerrar_ticket(
        interaction,
        owner_id,
        staff_role,
        closed_category,
        logs_channel,
        interaction.channel.id
    )


@bot.tree.command(name="add", description="A√±adir un usuario al ticket")
@app_commands.describe(user="Usuario a a√±adir al ticket")
async def add_user(interaction: discord.Interaction, user: discord.Member):
    data = cargar_datos()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        await interaction.response.send_message(
            "‚ùå Este no es un canal de ticket.",
            ephemeral=True
        )
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    ticket_data = data["tickets"][ticket_key]

    if staff_role not in interaction.user.roles and interaction.user.id != ticket_data["owner_id"]:
        await interaction.response.send_message(
            "‚ùå No tienes permiso para a√±adir usuarios.",
            ephemeral=True
        )
        return

    await interaction.channel.set_permissions(
        user,
        view_channel=True,
        send_messages=True,
        read_message_history=True
    )

    embed = discord.Embed(
        title="‚úÖ Usuario A√±adido",
        description=f"{user.mention} ha sido a√±adido al ticket.",
        color=COULEUR_SUCCES
    )

    await interaction.response.send_message(embed=embed)


@bot.tree.command(name="remove", description="Eliminar un usuario del ticket")
@app_commands.describe(user="Usuario a eliminar del ticket")
async def remove_user(interaction: discord.Interaction, user: discord.Member):
    data = cargar_datos()
    ticket_key = str(interaction.channel.id)

    if ticket_key not in data["tickets"]:
        await interaction.response.send_message(
            "‚ùå Este no es un canal de ticket.",
            ephemeral=True
        )
        return

    staff_role = discord.utils.get(interaction.guild.roles, name="Staff")
    ticket_data = data["tickets"][ticket_key]

    if staff_role not in interaction.user.roles:
        await interaction.response.send_message(
            "‚ùå Solo el staff puede eliminar usuarios.",
            ephemeral=True
        )
        return

    if user.id == ticket_data["owner_id"]:
        await interaction.response.send_message(
            "‚ùå No puedes eliminar al propietario del ticket.",
            ephemeral=True
        )
        return

    await interaction.channel.set_permissions(user, overwrite=None)

    embed = discord.Embed(
        title="‚úÖ Usuario Eliminado",
        description=f"{user.mention} ha sido eliminado del ticket.",
        color=COULEUR_SUCCES
    )

    await interaction.response.send_message(embed=embed)


@bot.command()
@commands.is_owner()
async def sync(ctx):
    synced = await bot.tree.sync()
    await ctx.send(f"‚úÖ Sincronizados {len(synced)} comandos: {[c.name for c in synced]}")


@bot.event
async def on_ready():
    print(f"‚úÖ Bot conectado como {bot.user}")
    print(f"üìä Servidores: {len(bot.guilds)}")
    print(f"üë• Usuarios: {len(bot.users)}")

    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching,
            name="[ServerName]"
        ),
        status=discord.Status.online
    )


bot.run("[TOKEN]")
